@cpp(src="ext-cpp/my_helper.cpp,ext-cpp/scheduler_basic.cpp", include="my_helper.hpp,scheduler_basic.hpp")
package sched
	// Constants definition
	const data int TASK_BUFFER_LIMIT = 255
	const data int EVENT_STACK_SIZE = 255
	const data int NO_TASK = 255
	const data int MAX_TASK_EXECUTION_STEP = 10
	const data int ENABLE = 1
	const data int DISABLE = 0
	const data int UNDEFINED = -1		

	// helper function definition
	extern function printf(string)
	extern function printf(string, int)
	extern function printf(string, int, int)
	extern function printf(string, string, int)
	extern function printf(string, string, int, int)
	// to get unique tID
	extern function int get_rand()
	extern function init_seed()
	// task queue in ScheulerBasicP.nc
	extern function scheuler_init()
	extern function int push_task(int id)
	extern function int pop_task()
	// event stack 
	extern function push(int)
	extern function int pop()
	extern function bool is_empty()
	extern function bool is_full()
	extern function create_stack(int)
	extern function destroy_stack()
	
	// Port dinfinition
	port type Port_t()
	port type Port_e (int eid)
	port type Port_ta (int appid)
	port type Port_ts (int status)
	port type Port_tte (int ext, string tname)
	port type Port_tta (int tid, int appid)

	// connectors 
	// basic 2-ports connector: rendz
	connector type Conn2(Port_t p1, Port_t p2)
		define p1 p2	
	end

	// for task to finish
	connector type Conn2_Finish(Port_tta p1, Port_t p2)
		define p1 p2	
		on p1 p2
		provided(p1.tid != 0 && p1.appid != 0)
	end
	
	// for posting task
	connector type Conn3_Post(Port_ta app ,Port_tta ts, Port_tta th_bound)	
		define app ts th_bound
		on app ts th_bound
		provided (th_bound.tid == 0)
		down {
			th_bound.tid = get_rand(); 
			th_bound.appid = app.appid;
			ts.tid = th_bound.tid;
			ts.appid = app.appid;
			printf(">>>>>>%d\n", th_bound.tid);		
		}
	end

	// for task beginning	
	connector type Conn3_Begin(Port_ts p1, Port_t p2, Port_t p3)
		define p1 p2 p3
		on p1 p2 p3
		down {
			printf(">>>>>>Conn3_Begin Task begin\n");
		}
	end

	// test: for 2 TH only , act like a boradcast
	connector type Conn3_Preem(Port_t p1, Port_tta p2, Port_tta p3)
		define p1 p2 p3
		on p1 p2 p3
		down {
			// stack the tids which are preempted
			push(p2.tid);
			push(p3.tid);
			printf(">>>>>> preempted tasks is stacked\n");
		}
	end

	connector type Conn3_Resume(Port_t p1, Port_t p2, Port_t p3)
		define p1 p2 p3
	end

	connector type Conn2_Signal(Port_t es, Port_t hw) 
		define es hw
		on es hw
		down {
			// generate eid
		}
	end

	// atom: Model of Task Schduler
	atom type TaskScheduler()
   		 // variable definition
    		data int task_count = 0
		data int ptv = UNDEFINED
		data int appid = UNDEFINED
		data int tid = UNDEFINED
		data int temp =UNDEFINED
		
   		 // port instance define
   		export port Port_t beg()
  		export port Port_t fin()
    		export port Port_tta post(tid, appid)	
		port Port_t tick() // spinning	

    		// place define
    		place FREE, BUSY

    		initial to FREE do {
			// initial of task queue
			scheuler_init(); 
			task_count = 0;
        			printf("[TS] initial to FREE  %d\n", task_count);
    		}

   		on beg from FREE to BUSY
		provided (task_count != 0)	
 		do {
			task_count = task_count - 1;
			printf("[TS] on beg from FREE to BUSY tc:%d\n", task_count);
		}

    		on post from FREE to FREE 
		provided (task_count < TASK_BUFFER_LIMIT)
		do{
			temp = push_task(tid);
			// add to queue
			if (tid != UNDEFINED && temp == ENABLE) 
			then 
				printf("------%d\n", tid);
				task_count = task_count + 1;
				printf("[TS] on post from FREE to FREE tc:%d\n", task_count);
			else 
				printf("[USER_DEFINE_ERROR] push failed: %d, errno: %d\n", tid, temp);
			fi
			temp =UNDEFINED;
		}

    		on post from BUSY to BUSY 
		provided (task_count < TASK_BUFFER_LIMIT)
		do{
			temp = push_task(tid);
			// add to queue
			if (tid !=UNDEFINED && temp == ENABLE) 
			then 
				task_count = task_count + 1;
				printf("[TS] on post from BUSY to BUSY tc:%d\n", task_count);
			else 
				printf("[USER_DEFINE_ERROR] push failed: %d, errno: %d\n", tid, temp);
			fi
			temp =UNDEFINED;
		}

    		on fin from BUSY to FREE do {
			ptv = pop_task();
			if(ptv == NO_TASK) 
			then 
				printf("[USER_DEFINE_ERROR] pop failed, NO_TASK\n");
			else 
				printf("------ popped task tid %d\n", ptv);
			fi
			printf("[TS] on fin from BUSY to FREE do tc:%d\n", task_count);
			ptv = UNDEFINED;
		}	

		on tick from FREE to FREE
		provided (task_count == 0)
		do {
			printf("[TS] TS is free now, spinnig\n");
		}
	end


	// the Atom Component of Event Scheduler
	atom type EventScheduler()
		// variable difination
		data int e_count = 0
		data int stack_size = 0
		data int is_es_idle = DISABLE

		// exported port defination
		export port Port_t beg()
		export port Port_t pre()
		export port Port_t res()
		export port Port_t fin()
		export port Port_t sig()
		export port Port_ts test(is_es_idle)
		
		// internal port difination
	
		// state defination
		place IDLE, ACCEPT, PREEMPT, BUSY1, BUSY2

		// behaviour defination
		initial to IDLE do {
			create_stack(EVENT_STACK_SIZE);
			is_es_idle = ENABLE;
			e_count = 0;
			stack_size = 0;
			printf("[ES] initial to IDLE, ec: %d, ss: %d \n", e_count, stack_size);
		}

		// only when ES is IDLE, TS can start a new task
		on test from IDLE to IDLE do {
			is_es_idle = ENABLE;
			printf("[ES] ES is still IDLE now, spinning\n");
		}

		on sig from IDLE to ACCEPT do {
			is_es_idle = DISABLE;
			printf("[ES] on sig from IDLE to ACCEPT, ec: %d, ss: %d\n", e_count, stack_size);
		} 

		on pre from ACCEPT to PREEMPT do {
			stack_size = stack_size + 1;
			printf("[ES] on pre from ACCEPT to PREEMPT, ec: %d, ss: %d\n", e_count, stack_size);
		}

		on beg from PREEMPT to BUSY1 do {
			e_count = e_count + 1;
			printf("[ES] on beg from PREEMPT to BUSY1, ec: %d, ss: %d\n", e_count, stack_size);
		}
		
		on fin from BUSY1 to IDLE 
		provided(stack_size == 0)
		do {
			e_count = e_count - 1;
			printf("[ES] on fin from BUSY1 to IDLE, ec: %d, ss: %d\n", e_count, stack_size);
		}
		
		on fin from BUSY1 to BUSY2
		provided(stack_size != 0)
		do {
			stack_size = stack_size - 1;
			e_count = e_count - 1;
			printf("[ES] on fin from BUSY1 to BUSY2\n");
			printf("ec: %d\n", e_count);
			printf("ss: %d\n", stack_size);
		}

		on res from BUSY2 to BUSY1
		provided(e_count > 0)
		do {
			printf("[ES] on res from BUSY2 to BUSY1, ec: %d, ss: %d\n", e_count, stack_size);
		}

		on res from BUSY2 to IDLE
		provided(e_count ==0)
		do {
			printf("[ES] on res from BUSY2 to IDLE, ec: %d, ss: %d\n", e_count, stack_size);
		}

		// priority definition, it means when 'sig' interaction comes, 'test' interaction must step back 
		// priority idle_state_change test < sig
		
	end	

	// atom type of Task Handler
	atom type TaskHandler()
		
		data int exe_step = 0
		data int tid = 0
		data int appid = 0

		// port definition 
		export port Port_tta init(tid, appid)
		export port Port_t beg()
		export port Port_tta fin(tid, appid)
		export port Port_tta pre(tid, appid)
		export port Port_t res()
		port Port_t exe()

		// state definition
		place IDLE, BOUND, EXE, SUSP

		// behavior definition
		initial to IDLE do {
			printf("[TH] initial to IDLE\n");
		}

		on init from IDLE to BOUND do {
			printf("[TH] on init from IDLE to BOUND do , appid: %d, tid: %d\n", appid, tid);
		}
		
		on beg from BOUND to EXE do{
			printf("[TH] on begin from IDLE to EXE, tid:%d\n", tid);
		} 

		// this is internal
		on exe from EXE to EXE 
		provided(exe_step < MAX_TASK_EXECUTION_STEP)
		do {
			exe_step = exe_step + 1;
			printf("[TH] Task is executing, tid:%d, step: %d\n", tid, exe_step);
		}

		on fin from EXE to IDLE do {
			printf("[TH] on fin from EXE to IDLE, tid:%d\n", tid);
		}

		on pre from EXE to SUSP do {
			printf("[TH] on pre from EXE to SUSP, th is premeeted, going to SUSPENd, tid:%d\n", tid);
		}

		on res from SUSP to EXE do {
			printf("on res from SUSP to EXE, tid:%d\n", tid);
		}
			
	end

	// atom type of Event Handler
	// atom type EventHandler()

		// port definition
		//export port Port_t pre()
		//export port Port_t res()
		//export port Port_t fin()
		//export port Port_t beg()
	// end

	// atom type of Command Handler
	// atom type CommandHandler()
		
		// port definition
		//export port Port_t pre()
		//export port Port_t res()
	//end
	
	atom type Timer( int timer_id) 
		data int expire_in = UNDEFINED
		data int count_down = UNDEFINED
		data string tname = ""
		// port definition
		export port Port_tte post(expire_in, tname)
		export port Port_t sig()
		port Port_t tick()
		
		// state definition
		place EXE, DONE
		
		// interaction definition
		initial to EXE do {
			count_down = 0;
			printf("[Timer] timer %d init\n", timer_id);
		}
	
		on post from EXE to EXE 
		provided (count_down == 0)
		do {
			count_down = expire_in;
			printf("[Timer] on post from EXE to EXE, new event set:%s, expire in:%d, timer ID: %d\n", tname, expire_in, timer_id);
		}

		on tick from EXE to EXE
		provided (count_down >= 1)
		do {
			// todo: real time related?
			count_down = count_down - 1;
		}
		
		on sig from EXE to DONE
		provided (count_down == 0)
		do {
			printf("[Timer] on sig from EXE to DONE,  event: %s, expire in %d\n, timer ID: %d", tname, expire_in, timer_id);
		}
	end

	atom type Sensor(int sid, string sname)		
		// port definition
		port Port_t beg()
		export port Port_t sig()
		data int sig_limit = UNDEFINED

		// state definition
		place IDLE, EXE

		initial to IDLE do {
			sig_limit = 1;
			printf("[Sensor] sensor %s begin, sid: %s\n", sname, sid);
		}
		
		on beg from IDLE to EXE do{
			printf("[Sensor] on beg from IDLE to EXE, sensor %s, sid: %s\n", sname, sid);
		} 

		on sig from EXE to EXE 
		provided(sig_limit > 0)
		do {	
			sig_limit = sig_limit - 1;	
			printf("[Sensor] on sig from EXE to EXE, sensor %s, sid: %s\n", sname, sid);
		}
		
	end

	// user defined software component
	atom type UserApplication(int _appid, int task_count)
		
		data int posted_task_count = 0
		data int appid
		
		// port definition
		export port Port_ta post(appid)
		port Port_t start()
		port Port_t ret()
		port Port_t fin()
		
		place INIT, POSTING, RUNNING, FIN

		initial to INIT do {
			init_seed();
			appid = _appid;
			printf("[UA] APP %d init\n", appid);
		} 
		
		on start from INIT to RUNNING do {
			printf("[UA] APP %d begins running\n", appid);
		}

		on post from RUNNING to POSTING 
		provided(posted_task_count < task_count)
		do {
			posted_task_count  = posted_task_count + 1;
			printf("[UA] APP %d posting a task\n", appid);	
		}
		
		on ret from POSTING to RUNNING do {
			printf("[UA] APP %d continue to run\n", appid); 
		}

		on fin from RUNNING to FIN 
		provided(posted_task_count == task_count)
		do {
			printf("[UA] APP %d is done\n", appid);
		}	
		
	end

	// main
	compound  type  Compound() 
		// components
    		component TaskScheduler ts()
		component EventScheduler es()

		// component Timer timer1(111)
		component Sensor sen1(111, "temperature")		

		component UserApplication app1(1, 2)
		component TaskHandler th_app1_1(), th_app1_2()
		
		// connectors
		// post task
		connector Conn3_Post post_task1(app1.post, ts.post, th_app1_1.init)
		connector Conn3_Post post_task2(app1.post, ts.post, th_app1_2.init)
		// the link of tasksched and its handler: begin
		connector Conn3_Begin begin_task1(es.test, th_app1_1.beg, ts.beg)					
		connector Conn3_Begin begin_task2(es.test, th_app1_2.beg, ts.beg)
		// the link of tasksched and its handler: finish
		connector Conn2_Finish fin_task1(th_app1_1.fin, ts.fin)
		connector Conn2_Finish fin_task2(th_app1_2.fin, ts.fin)	
		
		// the following is for test: meet the basic demanding
		connector Conn3_Preem test_pree(es.pre, th_app1_1.pre, th_app1_2.pre)
		connector Conn3_Resume test_res(es.res, th_app1_1.res, th_app1_2.res)

		// Sensor sig, it will sig anytime
		connector Conn2_Signal signal_1(es.sig, sen1.sig)
	end

end