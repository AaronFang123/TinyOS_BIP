@cpp(src="ext-cpp/my_helper.cpp, ext-cpp/scheduler_basic_p_c.cpp", include="my_helper.hpp, scheduler_basic_p_c.hpp")
package sched
	// Constants definition
	const data int TASK_BUFFER_LIMIT = 255
	const data int MAX_TASK_EXECUTION_STEP = 10
	const data int ENABLE = 1
	const data int DISABLE = 0		

	// helper function definition
	extern function printf(string)
	extern function printf(string, int)
	extern function printf(string, int, int)
	// to get unique TID
	extern function int get_rand()
	extern function init_seed()
	// task queue in ScheulerBasicP.nc
	extern function scheuler_init()
	extern function int push_task(int id)
	extern function int pop_task()
	
	// Port dinfinition
	port type Port_t()
	port type Port_ta (int appid)
	port type Port_ts (int status)
	port type Port_tta(int tid, int appid)

	// connectors
	connector type Conn2(Port_t p1, Port_t p2)
		define p1 p2	
	end
	
	// for posting task
	connector type Conn3_Post(Port_ta app ,Port_t ts, Port_tta th_bound)	
		define app ts th_bound
		on app ts th_bound down {th_bound.tid = get_rand(); th_bound.appid = app.appid;printf("------%d\n", th_bound.tid);}
	end

	// for task beginning	
	connector type Conn3_Begin(Port_ts p1, Port_t p2, Port_t p3)
		define p1 p2 p3
		on p1 p2 p3 provided (p1.status == ENABLE)
	end


	// atom: Model of Task Schduler
	atom type TaskScheduler()
   		 // variable definition
    		data int task_count = 0
		
   		 // port instance define
   		export port Port_t beg()
  		export port Port_t fin()
    		export port Port_t post()	
		port Port_t tick() // spinning	

    		// place define
    		place FREE, BUSY

    		initial to FREE do {
			task_count = 0;
        			printf("[TS] initial to FREE  %d\n", task_count);
    		}

   		on beg from FREE to BUSY
		provided (task_count != 0)	
 		do {
			task_count = task_count - 1;
			printf("[TS] on beg from FREE to BUSY tc:%d\n", task_count);
		}

    		on post from FREE to FREE 
		provided (task_count < TASK_BUFFER_LIMIT)
		do{
			task_count = task_count + 1;
			printf("[TS] on post from FREE to FREE tc:%d\n", task_count);
		}

    		on post from BUSY to BUSY 
		provided (task_count < TASK_BUFFER_LIMIT)
		do{
			task_count = task_count + 1;
			printf("[TS] on post from BUSY to BUSY tc:%d\n", task_count);
		}

    		on fin from BUSY to FREE do {
			printf("[TS] on fin from BUSY to FREE do tc:%d\n", task_count);
		}	

		on tick from FREE to FREE
		provided (task_count == 0)
		do {
			printf("[TS] TS is free now, spinnig\n");
		}
	end


	// the Atom Component of Event Scheduler
	atom type EventScheduler()
		// variable difination
		data int e_count = 0
		data int stack_size = 0
		data int is_es_idle = DISABLE

		// exported port defination
		export port Port_t beg()
		export port Port_t pre()
		export port Port_t res()
		export port Port_t fin()
		export port Port_t sig()
		export port Port_ts test(is_es_idle)
		
		// internal port difination
	
		// state defination
		place IDLE, ACCEPT, PREEMPT, BUSY1, BUSY2

		// behaviour defination
		initial to IDLE do {
			is_es_idle = ENABLE;
			e_count = 0;
			stack_size = 0;
			printf("[ES] initial to IDLE, ec: %d, ss: %d \n", e_count, stack_size);
		}

		// only when ES is IDLE, TS can start a new task
		on test from IDLE to IDLE do {
			is_es_idle = ENABLE;
			printf("[ES] ES is still IDLE now, spinning\n");
		}

		on sig from IDLE to ACCEPT do {
			is_es_idle = DISABLE;
			printf("[ES] on sig from IDLE to ACCEPT, ec: %d, ss: %d\n", e_count, stack_size);
		} 

		on pre from ACCEPT to PREEMPT do {
			stack_size = stack_size + 1;
			printf("[ES] on pre from ACCEPT to PREEMPT, ec: %d, ss: %d\n", e_count, stack_size);
		}

		on beg from PREEMPT to BUSY1 do {
			e_count = e_count + 1;
			printf("[ES] on beg from PREEMPT to BUSY1, ec: %d, ss: %d\n", e_count, stack_size);
		}
		
		on fin from BUSY1 to IDLE 
		provided(stack_size == 0)
		do {
			e_count = e_count - 1;
			printf("[ES] on fin from BUSY1 to IDLE, ec: %d, ss: %d\n", e_count, stack_size);
		}
		
		on fin from BUSY1 to BUSY2
		provided(stack_size != 0)
		do {
			stack_size = stack_size - 1;
			e_count = e_count - 1;
			printf("[ES] on fin from BUSY1 to BUSY2\n");
			printf("ec: %d\n", e_count);
			printf("ss: %d\n", stack_size);
		}

		on res from BUSY2 to BUSY1
		provided(e_count > 0)
		do {
			printf("[ES] on res from BUSY2 to BUSY1, ec: %d, ss: %d\n", e_count, stack_size);
		}

		on res from BUSY2 to IDLE
		provided(e_count ==0)
		do {
			printf("[ES] on res from BUSY2 to IDLE, ec: %d, ss: %d\n", e_count, stack_size);
		}

		// priority definition, it means when 'sig' interaction comes, 'test' interaction must step back 
		priority idle_state_change test < sig
		
	end	

	// atom type of Task Handler
	atom type TaskHandler()
		
		data int exe_step = 0
		data int tid = 0
		data int appid = 0

		// port definition 
		export port Port_tta init(tid, appid)
		export port Port_t beg()
		export port Port_t fin()
		export port Port_t pre()
		export port Port_t res()
		port Port_t exe()

		// state definition
		place IDLE, BOUND, EXE, SUSP

		// behavior definition
		initial to IDLE do {
			printf("[TH] initial to IDLE\n");
		}

		on init from IDLE to BOUND do {
			printf("[TH] on init from IDLE to BOUND do , appid: %d, tid: %d\n", appid, tid);
		}
		
		on beg from BOUND to EXE do{
			printf("[TH] on begin from IDLE to EXE, tid:%d\n", tid);
		} 

		// this is internal
		on exe from EXE to EXE 
		provided(exe_step < MAX_TASK_EXECUTION_STEP)
		do {
			exe_step = exe_step + 1;
			printf("[TH] Task is executing, tid:%d\n", tid);
		}

		on fin from EXE to IDLE do {
			printf("[TH] on fin from EXE to IDLE, tid:%d\n", tid);
		}

		on pre from EXE to SUSP do {
			printf("[TH] on pre from EXE to SUSP, tid:%d\n", tid);
		}

		on res from SUSP to EXE do {
			printf("on res from SUSP to EXE, tid:%d\n", tid);
		}
			
	end

	// atom type of Event Handler
	// atom type EventHandler()

		// port definition
		//export port Port_t pre()
		//export port Port_t res()
		//export port Port_t fin()
		//export port Port_t beg()
	// end

	// atom type of Command Handler
	// atom type CommandHandler()
		
		// port definition
		//export port Port_t pre()
		//export port Port_t res()
	//end

	// user defined software component
	atom type UserApplication(int _appid, int task_count)
		
		data int posted_task_count = 0
		data int appid
		
		// port definition
		export port Port_ta post(appid)
		port Port_t start()
		port Port_t ret()
		port Port_t fin()
		
		place INIT, POSTING, RUNNING, FIN

		initial to INIT do {
			init_seed();
			appid = _appid;
			printf("[UA] APP %d init\n", appid);
		} 
		
		on start from INIT to RUNNING do {
			printf("[UA] APP %d begins running\n", appid);
		}

		on post from RUNNING to POSTING 
		provided(posted_task_count < task_count)
		do {
			posted_task_count  = posted_task_count + 1;
			printf("[UA] APP %d posting a task\n", appid);	
		}
		
		on ret from POSTING to RUNNING do {
			printf("[UA] APP %d continue to run\n", appid); 
		}

		on fin from RUNNING to FIN 
		provided(posted_task_count == task_count)
		do {
			printf("[UA] APP %d is done\n", appid);
		}	
		
	end

	// main
	compound  type  Compound() 
		// components
    		component TaskScheduler ts()
		component EventScheduler es()		

		component UserApplication app1(1, 2)
		component TaskHandler th_app1_1(), th_app1_2()
		
		// connectors
		// post task
		connector Conn3_Post post_task1(app1.post, ts.post, th_app1_1.init)
		connector Conn3_Post post_task2(app1.post, ts.post, th_app1_2.init)
		// the link of tasksched and its handler: begin
		connector Conn3_Begin begin_task1(es.test, th_app1_1.beg, ts.beg)					
		connector Conn3_Begin begin_task2(es.test, th_app1_2.beg, ts.beg)
		// the link of tasksched and its handler: finish
		connector Conn2 fin_task1(th_app1_1.fin, ts.fin)
		connector Conn2 fin_task2(th_app1_2.fin, ts.fin)	
	end

end