@cpp(src="ext-cpp/my_helper.cpp,ext-cpp/scheduler_basic.cpp,ext-cpp/trace_helper.cpp",include="my_helper.hpp,scheduler_basic.hpp,trace_helper.hpp")
package sched
	// Constants definition
	const data int TASK_BUFFER_LIMIT = 255
	const data int NO_TASK = 255
	const data int MAX_TASK_EXECUTION_STEP = 5
	const data int UNDEFINED = -1
	const data int ENABLE = 1
	const data int DISABLE = 0

	// transported msg
	extern data type message_t

	extern function message_t init_msg_value(int)
	extern function set_message_t(int, message_t, int, int, int,int, int)
	extern function print_message_t(message_t)
	extern function message_t get_null_message()
	extern function int get_msg_des(message_t)
	extern function int get_msg_data(message_t)
	// helper function definition
	extern function printf(string)
	extern function printf(string, int)
	extern function printf(string, int, int)
	extern function printf(string, int, int, int)
	extern function print_led(int, int, int, int) 
	// to get unique tID/eID
	extern function int get_rand(int)
	extern function init_seed()
	// task queue in ScheulerBasicP.nc
	extern function scheuler_init(int)
	extern function int push_task(int, int)
	extern function int pop_task(int)
	extern function int get_task_count(int)
	// event stack 
	extern function push(int, int)
	extern function int pop(int)
	extern function bool stack_is_empty(int)
	extern function bool is_full(int)
	extern function int get_size(int)
	extern function create_stack(int, int)
	// trace
	extern function trace_i(string, int)
	
	// Port dinfinition
	port type Port_t()
	port type Port_tv(int v)
	port type Port_tm(message_t msg)
	port type Port_tvm(int v, message_t msg)
	port type Port_tvv(int v1, int v2)
	port type Port_tv3(int v1, int v2, int v3)
	port type Port_tv4(int v1, int v2, int v3, int v4)
	port type Port_tta (int tid, int appid) // for pre and res only
	port type Port_tmv2(int v1, int v2, message_t msg)
	
	// connectors 
	// basic 2-ports connector: rendz
	connector type Conn2(Port_t p1, Port_t p2)
		define p1 p2	
	end

	connector type Conn3_Basic (Port_t p1, Port_t p2, Port_t p3) 
		define p1 p2 p3
	end
	
	connector type Conn4_Basic (Port_t p1, Port_t p2, Port_t p3, Port_t p4) 
		define p1 p2 p3 p4
	end	
	
	connector type Conn4_Sen_Begin (Port_t appsig, Port_t combeg, Port_tvv s_r, Port_tvv envread)
		define appsig combeg s_r envread
		on appsig combeg s_r envread
		down {
			s_r.v1 = envread.v1;
			s_r.v2 = envread.v2;
		}
	end

	connector type Conn2_V2(Port_tv p1, Port_tv p2)
		define p1 p2	// sen env
		on p1 p2
		down { p1.v = p2.v; }
	end

	// for task to finish
	connector type Conn3_Finish(Port_tta p1, Port_t p2, Port_t p3)
		define p1 p2 p3	
		on p1 p2 p3
	end

	// test: for 4-TH/CH only , act like a boradcast
	connector type Conn7_Preem(Port_tv es, Port_tta p1, Port_tta p2, Port_tta p3, Port_tta p4, Port_tta p5, Port_tta p6)
		define es' p1 p2 p3 p4 p5 p6
		on es                        down {
			printf("                [Conn7_Preem] no task is preemted, go on \n");
		}
		on es  p1                  down {
			push(p1.appid, p1.tid);
			printf("                [Conn7_Preem] preempted tasks is stacked, %d\n", p1.tid);
		}
		on es     p2               down {
			push(p2.appid, p2.tid);
			printf("                [Conn7_Preem] preempted tasks is stacked, %d\n", p2.tid);
		}
		on es           p3         down {
			push(p3.appid, p3.tid);
			printf("                [Conn7_Preem] preempted tasks is stacked, %d\n", p3.tid);
		}
		on es               p4     down {
			push(p4.appid, p4.tid);
			printf("                [Conn7_Preem] preempted tasks is stacked, %d\n", p4.tid);
		}
		on es                   p5 down {
			push(p5.appid, p5.tid);
			printf("                [Conn7_Preem] preempted tasks is stacked, %d\n", p5.tid);
		}
		on es                       p6 down {
			push(p6.appid, p6.tid);
			printf("                [Conn7_Preem] preempted tasks is stacked, %d\n", p6.tid);
		}	
	end

	connector type Conn3_Timer_Sig(Port_t timer, Port_tv es, Port_tv3 eh)
		define timer es eh
		on timer es eh
		down {
			eh.v1 = get_rand(255); 
			eh.v2 = -2;
			eh.v3 = -2;
			es.v = eh.v1;	
		}
	end
	
	connector type Conn4_Post_Task(Port_tm ehrec, Port_t led, Port_tmv2 thinit, Port_tta ts)
		define  ehrec led thinit ts
		on ehrec led thinit ts
		down {
			thinit.msg = ehrec.msg;
			ts.appid = thinit.v1;
			thinit.v2 = get_rand(255); 
			ts.tid = thinit.v2;
		}
			
	end

	connector type Conn_Sen_Ch_Beg (Port_t chbeg, Port_t led, Port_tvv senread, Port_tvv envread, Port_t timsig)
		define chbeg led senread envread timsig
		on chbeg led senread envread timsig
		down {
			senread.v1 = envread.v1;
			senread.v2 = envread.v2;
		}
	end

	connector type Conn3_Datamsg_Senddone(Port_tvv ehinit, Port_tv sndsig, Port_tv essig)
		define ehinit sndsig essig 
		on ehinit sndsig essig
		down {
			ehinit.v1 = get_rand(255);
			ehinit.v2 = sndsig.v;
			essig.v = ehinit.v1;
		}
	end

	connector type Conn_Sig_Photo_Read (Port_tv3 sensig, Port_tv essig,  Port_tv3 ehinit, Port_t chsig)
		define sensig essig ehinit chsig
		on sensig essig ehinit chsig
		down {
			ehinit.v1 = get_rand(255);
			ehinit.v2 = sensig.v2;
			ehinit.v3 = sensig.v3;
			essig.v = ehinit.v1;
		}
	end

	connector type Conn_Data_Receive(Port_tv essig, Port_tm rcvlis, Port_tvm ehinit)
		define essig rcvlis ehinit
		on essig rcvlis ehinit
		down {
			ehinit.v = get_rand(255);
			ehinit.msg = rcvlis.msg;
			essig.v = ehinit.v;
		}
	end

	connector type Conn3_Radio_Senddone(Port_tv p1, Port_tv p2, Port_t p3)
		define p1 p2 p3
		on p1 p2 p3
		down { p1.v = p2.v; }
	end

	// pass p1's value(message_t) to p2
	connector type Conn2_M(Port_tm p1, Port_tm p2)
		define p1 p2
		on p1 p2
		down { p2.msg = p1.msg; }
	end

	connector type Conn_CSMACA_UP(Port_tvm snd, Port_tmv2 chan) 
		data int n_rate
		define snd chan
		on snd chan
		down { 
			// chan v1: rate, chan v2 result
			n_rate = get_rand(100);
			if (chan.v1 > n_rate) then
				// failed
				chan.v2 = DISABLE;
				snd.v = DISABLE;
				printf("                [Sender-Conn_CSMACA_UP] send failed, stop.\n");
			else
				chan.v2 = ENABLE;
				chan.msg = snd.msg;
				snd.v = ENABLE;
			fi
		}
	end  

	connector type Conn2_CSMACA_DOWN(Port_tvm chan, Port_tvm des)
		define chan des
		on chan des
		provided(chan.v == des.v)
		down { des.msg = chan.msg; }
	end

	// atom: Model of Task Schduler
	atom type TaskScheduler(int did, int enable)
   		 // variable definition
    		data int task_count = 0
		data int ptv = UNDEFINED
		data int appid = UNDEFINED
		data int tid = UNDEFINED
		data int temp =UNDEFINED
		data int flag_is_running = DISABLE
		
   		 // port instance define
		export port Port_t init()
   		export port Port_t beg()
  		export port Port_t fin()
    		export port Port_tta post(tid, appid)	

    		// place define
    		place BOOT, FREE, BUSY

		initial to BOOT
		
  		// initial of task queue
		on init from BOOT to FREE delayable do { scheuler_init(did);}

   		on beg from FREE to BUSY provided (task_count != 0 && flag_is_running == DISABLE && enable == ENABLE) delayable
 		do {	
			flag_is_running = ENABLE;
			pop_task(did);
			task_count = get_task_count(did);
			printf("                [TS] on beg from FREE to BUSY tc:%d\n", task_count);
		}

    		on post from FREE to FREE provided (task_count < TASK_BUFFER_LIMIT && enable == ENABLE) delayable
		do{
			temp = push_task(did, tid);
			// add to queue
			if (tid != UNDEFINED && temp == ENABLE) 
			then 
				task_count = get_task_count(did);
				printf("                [TS] on post from FREE to FREE, new tid: %d, tc:%d\n", tid, task_count);
			else 
				printf("                [USER_DEFINE_ERROR] push failed: %d, errno: %d\n", tid, temp);
			fi
			temp = UNDEFINED;
		}

    		on post from BUSY to BUSY provided (task_count < TASK_BUFFER_LIMIT) delayable
		do{
			temp = push_task(did, tid);
			// add to queue
			if (tid != UNDEFINED && temp == ENABLE) 
			then 
				task_count = get_task_count(did);
				printf("                [TS] on post from BUSY to BUSY tc:%d\n", task_count);
			else 
				printf("                [USER_DEFINE_ERROR] push failed: %d, errno: %d\n", tid, temp);
			fi
			temp = UNDEFINED;
		}

    		on fin from BUSY to FREE delayable 
		do {
			flag_is_running = DISABLE;
			printf("                [TS] on fin from BUSY to FREE do tc:%d\n", task_count);
			tid = UNDEFINED;
		}	

	end

	// the Atom Component of Event Scheduler
	atom type EventScheduler(int did)
		// variable difination
		data int e_count = UNDEFINED
		data int stack_size = UNDEFINED
		data int eid = UNDEFINED
		data int popped_id = UNDEFINED
		export data int is_es_idle = DISABLE
		// exported port defination
		export port Port_t init()
		export port Port_t beg()
		export port Port_tv pre(eid)
		export port Port_t fin()
		export port Port_tv sig(eid)
		export port Port_t res()
		export port Port_tv test(is_es_idle)
	
		// state defination
		place INIT, IDLE, ACCEPT, PREEMPT, BUSY1, BUSY2
		
		// behaviour defination
		initial to INIT

		on init from INIT to IDLE delayable 
		do {
			create_stack(did, 255);
			is_es_idle = ENABLE;
			e_count = 0;
			stack_size = 0;
			printf("                [ES] initial to IDLE, ec: %d, ss: %d \n", e_count, stack_size);
		}

		// only when ES is IDLE, TS can start a new task
		on test from IDLE to IDLE delayable do {is_es_idle = ENABLE;}

		on sig from IDLE to ACCEPT delayable do {
			is_es_idle = DISABLE;
			printf("                [ES] on sig from IDLE to ACCEPT, ec: %d, ss: %d\n", e_count, stack_size);
		} 

		on pre from ACCEPT to PREEMPT delayable 
		do {
			stack_size = get_size(did);
			printf("                [ES] on pre from ACCEPT to PREEMPT, ec: %d, ss: %d\n", e_count, stack_size);
		}

		on beg from PREEMPT to BUSY1 delayable 
		do {
			stack_size = get_size(did);
			e_count = e_count + 1;
			printf("                [ES] on beg from PREEMPT to BUSY1, ec: %d, ss: %d\n", e_count, stack_size);
		}	
		
		on fin from BUSY1 to IDLE provided(stack_size == 0) delayable
		do {
			is_es_idle = ENABLE;
			e_count = e_count - 1;
			printf("                [ES] on fin from BUSY1 to IDLE, ec: %d, ss: %d\n", e_count, stack_size);
			popped_id = UNDEFINED;
			eid = UNDEFINED;
		}
		
		on fin from BUSY1 to BUSY2 provided(stack_size != 0) delayable
		do {
			popped_id = pop(did); 	// pop from stack
			stack_size = get_size(did);
			e_count = e_count - 1;
			printf("                [ES] on fin from BUSY1 to BUSY2, ec: %d, ss: %d,  popped id: %d\n", e_count, stack_size, popped_id);
			popped_id = UNDEFINED;
			eid = UNDEFINED;
		}

		on res from BUSY2 to BUSY1 provided(e_count > 0) delayable
		do {
			printf("                [ES] on res from BUSY2 to BUSY1, ec: %d, ss: %d\n", e_count, stack_size);
		}

		on res from BUSY2 to IDLE provided(e_count == 0) delayable
		do {
			is_es_idle = ENABLE;
			printf("                [ES] on res from BUSY2 to IDLE, ec: %d, ss: %d\n", e_count, stack_size);
		}
	end	

	// atom type of Task and Event Handler
	atom type TH_AVG(int _appid)

		data int tid = UNDEFINED
		data int appid = UNDEFINED
		data message_t msg
		data int avg_temperature = 0
		data int counter = 0
		data int temp = 0

		// port definition 
		export port Port_tmv2 init(appid, tid, msg)
		export port Port_t beg()
		export port Port_tta fin(tid, appid)
		export port Port_tta pre(tid, appid)
		export port Port_t res()

		// state definition
		place IDLE, BOUND, EXE, SUSP

		// behavior definition
		initial to IDLE do {
			msg = get_null_message();
			appid = _appid;
		}

		on init from IDLE to BOUND delayable
		
		on beg from BOUND to EXE delayable

		on fin from EXE to IDLE delayable do {
			temp = get_msg_data(msg);
			if(temp > 0) then
				avg_temperature = ((avg_temperature * counter) + temp) / (counter + 1);		
				printf("                [TH_AVG] recevied temperature: %d, avg temp is %d, totally %d\n", temp, avg_temperature, counter);
				counter = counter + 1;
			fi
		}

		on pre from EXE to SUSP delayable
		on res from SUSP to EXE delayable
			
	end

	// each time period the EH_Timer may execute once
	atom type EH_Timer(int _appid)
		// data definition
		data int eid = UNDEFINED
		data int appid = UNDEFINED

		// port definition 
		export port Port_tv init(eid)
		export port Port_t beg()
		export port Port_tta pre(eid, appid)
		export port Port_t res()
		export port Port_tv call(eid)

		// state definition
		place IDLE, BOUND, EXE, SUSP

		// behavior definition
		initial to IDLE do { appid = _appid; }

		on init from IDLE to BOUND delayable
		
		on beg from BOUND to EXE delayable
		// 1. call Leds.led1Toggle()
		// 2. call Photo.read()
		on call from EXE to IDLE delayable

		on pre from EXE to SUSP delayable

		on res from SUSP to EXE delayable
			
	end

	atom type CH_Photo_Read(int _cid, int _appid)

		data int appid = UNDEFINED
		data int cid = UNDEFINED
		// port definition 
		export port Port_t beg()
		export port Port_tta pre(cid, appid)
		export port Port_t res()
		export port Port_t sig()
		
		// state definition
		place IDLE, EXE, SUSP

		// behavior definition
		initial to IDLE do { 
			appid = _appid;
			cid = _cid;
		}
		
		on beg from IDLE to EXE delayable

		on sig from EXE to IDLE delayable

		on pre from EXE to SUSP delayable

		on res from SUSP to EXE delayable

	end

	atom type EH_Photo_ReadDone(int _appid, int desid)
		// data definition
		data int eid = UNDEFINED	
		data int result = UNDEFINED
		data int value = UNDEFINED
		data int flag_last_estate = UNDEFINED
		data int flag_send = UNDEFINED
		data int appid = UNDEFINED
		data message_t msg
		data int seq = 0

		// port definition 
		export port Port_tv3 init(eid, result, value)
		export port Port_t beg()
		export port Port_tta pre(eid, appid)
		export port Port_t res()
		export port Port_tm call_send(msg)
		export port Port_tv get_report(flag_send)
		export port Port_t call_led2()
		export port Port_t fail()

		// state definition
		place IDLE, BOUND, E1, E2, E3, SUSP

		// behavior definition
		initial to IDLE do { 
			msg = init_msg_value(_appid);
			appid = _appid; 
		}

		on init from IDLE to BOUND delayable
		
		on beg from BOUND to E1 delayable
		do { 
			if(result == ENABLE) then
				set_message_t(appid, msg, seq, 0, appid, desid, value);
				print_message_t(msg);
				seq = seq + 1;
			fi
		}
		// set data to send
		on fail from E1 to IDLE provided (result == DISABLE) delayable
		do { printf("              [EH_Photo_ReadDone] appid: %d, read failed\n", appid); }

		// send data
		on call_send from E1 to E2 provided (result == ENABLE) delayable

		on get_report from E2 to E3 delayable

		on call_led2 from E3 to IDLE provided(flag_send == ENABLE) delayable

		on pre from E1 to SUSP delayable do {flag_last_estate = 1;}
		on pre from E2 to SUSP delayable do {flag_last_estate = 2;}
		on pre from E3 to SUSP delayable do {flag_last_estate = 3;}

		on res from SUSP to E1  provided(flag_last_estate == 1) delayable
		on res from SUSP to E2  provided(flag_last_estate == 2) delayable
		on res from SUSP to E3  provided(flag_last_estate == 3) delayable

	end

	atom type CH_DataMsg_Send(int _cid, int _appid)
		// data definition
		data int read_state = UNDEFINED
		data int flag_last_e = UNDEFINED
		data int appid = UNDEFINED
		data int cid = UNDEFINED
		data message_t msg		

		// port definition 
		export port Port_tm beg(msg)
		export port Port_tta pre(cid, appid)
		export port Port_t res()
		export port Port_t sig()
		export port Port_tm send(msg)
		
		// state definition
		place IDLE, E1, E2, SUSP

		// behavior definition
		initial to IDLE do { 
			appid = _appid; 
			cid = _cid;
			msg = get_null_message();
		}
		
		on beg from IDLE to E1 delayable

		on send from E1 to E2 delayable
		
		on sig from E2 to IDLE delayable

		on pre from E1 to SUSP delayable do {flag_last_e = 1;}
		on pre from E2 to SUSP delayable do {flag_last_e = 2;}

		on res from SUSP to E1  provided(flag_last_e == 1)  delayable
		on res from SUSP to E2  provided(flag_last_e == 2)  delayable

	end
	
	atom type EH_DataMsg_SendDone(int _appid)
		// data definition
		data int eid = UNDEFINED	
		data int flag_error = UNDEFINED
		data int appid = UNDEFINED
		
		// port definition 
		export port Port_tvv init(eid, flag_error)
		export port Port_t beg()
		export port Port_tta pre(eid, appid)
		export port Port_t res()
		export port Port_t call()
		export port Port_t fail()

		// state definition
		place IDLE, BOUND, EXE, SUSP, FAILED

		// behavior definition
		initial to IDLE do { appid = _appid; }

		on init from IDLE to BOUND delayable
		
		on beg from BOUND to EXE delayable
	
		// set data to send
		on call from EXE to IDLE provided (flag_error == ENABLE) delayable
 
		// send data failed
		on fail from EXE to IDLE provided (flag_error == DISABLE) delayable
		do { printf("	[EH_DataMsg_SendDone-Exception] Send failed! from did: %d", appid); }

		on pre from EXE to SUSP delayable

		on res from SUSP to EXE delayable

	end

	atom type EH_Recvmsg_Receive(int _appid)
		// data definition
		data int eid = UNDEFINED
		data int appid = UNDEFINED
		data message_t payload

		// port definition 
		export port Port_tvm init(eid, payload)
		export port Port_t beg()
		export port Port_tta pre(eid, appid)
		export port Port_t res()
		export port Port_tm call(payload)

		// state definition
		place IDLE, BOUND, EXE, SUSP

		// behavior definition
		initial to IDLE do { 
			appid = _appid; 
			payload = get_null_message();
		}

		on init from IDLE to BOUND delayable

		on beg from BOUND to EXE delayable
		
		on call from EXE to IDLE delayable do { print_message_t(payload); }
		// set data to send

		on pre from EXE to SUSP delayable

		on res from SUSP to EXE delayable

	end

	atom type Timer_New( int timer_id, int expire_in, int is_one_shot) 

		data int flag_is_posted = DISABLE

		clock x unit millisecond
		clock tu unit millisecond

		// port definition
		export port Port_t post()
		export port Port_t sig()
		export port Port_t stop()
		export port Port_t interval()
		
		// state definition
		place INIT, EXE, DONE
		
		// interaction definition
		initial to INIT do { 
			x = 0;
			tu' =0; 
			tu = 1;
		}
	
		on post from INIT to EXE provided (flag_is_posted == DISABLE && is_one_shot == DISABLE) delayable
		do {
			printf("		[Timer]<<<<<<<[post] %Ld\n", x / tu);
			flag_is_posted = ENABLE;
			x = 0;
			
		}

		on interval from INIT to EXE provided (x == expire_in && flag_is_posted == ENABLE) delayable
		do {
			printf("                         [Timer]<<<<<<<[interval] %Ld\n", x / tu);
			x = 0;
		}

		
		on sig from EXE to INIT provided (is_one_shot == DISABLE) delayable
		do {
			// start a interval 
			printf("                         [Timer]<<<<<<<[sig] %Ld\n", x / tu);
			x = 0;
		}

		on sig from EXE to DONE provided (is_one_shot == ENABLE) delayable

		on stop from EXE to INIT delayable 
		do { x = 0;	}

	end

	atom type Sensor(int _sid)		
		// data definition
		data int sid = UNDEFINED
		data int is_idle = UNDEFINED
		data int read_value = UNDEFINED
		data int read_state = UNDEFINED

		// port definition
		export port Port_tv3 sig(sid, read_state, read_value)
		export port Port_tvv read(read_state, read_value)	
		export port Port_tv test(is_idle)
	
		// state definition
		place E1, E2

		initial to E1 do {
			sid = _sid;
			is_idle = ENABLE;
			read_value = DISABLE;
			read_state = DISABLE;
		}

		on read from E1 to E2 delayable do{
			is_idle = ENABLE;
			printf("                [Sensor] on beg from EXE1 to EXE2, sid: %d\n", sid);
		}

		on sig from E2 to E1 delayable do {	
			is_idle = DISABLE;
			printf("                [Sensor] on sig from EXE2 to EXE1, sid: %d\n", sid);
		}

		on test from E1 to E1 delayable
		
		on test from E2 to E2 delayable

	end

	// Boot sequence of TOS
	atom type NodeBoot(int appid) 
		
		export port Port_t enable_interrupt()
		export port Port_t booted()
		export port Port_t sched_init()
		port Port_t platform_init()
		port Port_t task_loop()
		
		// NE: negative, SI: scheduler init, PI: plattfrom init, IE: interrupt enable, BO: booted, SC: scheduler task loop
		place NE, SI, PI, IE, BO, SC

		initial to NE

		on sched_init from NE to SI delayable do {
			init_seed();
			printf("                [TOS_BOOT] from node %d, 1. scheduler init\n", appid);
		}

		on platform_init from SI to PI delayable do {
			printf("                [TOS_BOOT] from node %d 2. platform init\n", appid);
		}

		on enable_interrupt from PI to IE delayable do {
			printf("                [TOS_BOOT] from node %d 3. enable interrupt\n", appid);
		}

		on booted from IE to BO delayable do {
			printf("                [TOS_BOOT] from node %d 4. booted\n", appid);
		}

		on task_loop from BO to SC delayable do {
			printf("                [TOS_BOOT] from node %d 5. task loop begin\n", appid);
		}

	end

	// Demo Application
	atom type SampleApplication(int _appid, int task_count, int signal_count)

		data int posted_task_count = 0
		data int signaled_count = 0
		data int appid = 0
		
		// port definition
		export port Port_tv post(appid)
		export port Port_t sig()
		export port Port_t booted()
		port Port_t start()
		port Port_t fin()
		
		place BOOT, INIT, RUNNING, FIN
	
		initial to BOOT

		on booted from BOOT to INIT do {
			appid = _appid;
			printf("                [UA] APP %d init\n", appid);
		}

		on start from INIT to RUNNING

		on post from RUNNING to RUNNING provided(posted_task_count < task_count)
		do {
			posted_task_count  = posted_task_count + 1;
			printf("                [UA] APP %d posting a task\n", appid);	
		}

		on sig from RUNNING to RUNNING provided (signaled_count < signal_count) 
		do {
			signaled_count = signaled_count + 1;
			printf("                [UA] APP %d signal a event\n", appid);
		}

		on fin from RUNNING to FIN provided(posted_task_count == task_count && signaled_count == signal_count)
		do {
			printf("                [UA] APP %d is done\n", appid);
		}	
		
	end

	atom type RadioSender(int did)
		// data definition
		data message_t packet
		data int flag_send_enable = DISABLE
		data int flag_send_succeed = DISABLE // todo

		// port definition
		export port Port_tv sig(flag_send_succeed)
		export port Port_tvm broadcast(flag_send_succeed, packet)
		export port Port_tm syn_send(packet)
		export port Port_tv test(flag_send_enable)
		
		// place definition
		place IDLE, SEND, FIN

		// interaction definition
		initial to IDLE do {
			flag_send_enable = DISABLE;
			packet = get_null_message();
		}
		
		on syn_send from IDLE to SEND delayable do {flag_send_enable = ENABLE;}

		on broadcast from SEND to FIN delayable do {flag_send_enable = ENABLE;}

		on sig from FIN to IDLE delayable do {flag_send_enable = DISABLE;}
		
		on test from IDLE to IDLE delayable
		on test from SEND to SEND delayable
		on test from FIN to FIN delayable

	end
	
	atom type RadioReceiver(int _did)
		// data dedinition
		data message_t packet
		data int did = UNDEFINED
		// port definition
		export port Port_tvm listen(did, packet)
		export port Port_tm sig(packet)

		// place definition
		place IDLE, RECV
		
		// interaction definition
		initial to IDLE do { 
			did = _did;
			packet = get_null_message();
		}

		on listen from IDLE to RECV delayable

		on sig from RECV to IDLE delayable

	end

	atom type LED(int appid)

		data int led0 = 0
		data int led1 = 0
		data int led2 = 0
		
		export port Port_t led0on()
		export port Port_t led1on()
		export port Port_t led2on()

		export port Port_t led0off()
		export port Port_t led1off()
		export port Port_t led2off()
	
		place SET

		initial to SET

		on led0on from SET to SET delayable do {
			led0 = 1;
			print_led(appid, led0, led1, led2);
		}
		on led1on from SET to SET delayable do {
			led1 = 1;
			print_led(appid, led0, led1, led2);
		}
		on led2on from SET to SET delayable do {
			led2 = 1;
			print_led(appid, led0, led1, led2);
		}

		on led0off from SET to SET delayable do {
			led0 = 0;
			print_led(appid, led0, led1, led2);
		}
		on led1off from SET to SET delayable do {
			led1 = 0;
			print_led(appid, led0, led1, led2);
		}
		on led2off from SET to SET delayable do {
			led2 = 0;
			print_led(appid, led0, led1, led2);
		}

	end

	// for Sensor, it will provide a random value as the return of sensors
	atom type Environment(int rate) 
		// data definition
		data int value
		data int state
		// port definition
		export port Port_tvv read(state, value)
		// state definition
		place DO
		// interaction definition
		initial to DO do {
			value = get_rand(100);
			if (value > rate) then
				state = DISABLE;
			else
				state = ENABLE;
			fi
		}
			
		on read from DO to DO delayable do {
			value = get_rand(100);
			if (value > rate) then
				state = DISABLE;
			else
				state = ENABLE;
			fi
		}

	end	

	atom type Channel(int rate)

		data int is_channel_busy = UNDEFINED
		data int succ_rate = UNDEFINED
		data int state = UNDEFINED
		data message_t packet
		data int des = UNDEFINED
		
		export port Port_tmv2 upload(succ_rate ,state, packet)
		export port Port_tvm download(des, packet)
		port Port_t done()
		port Port_t fail()
		
		place IDLE, BUSY1, BUSY2

		initial to IDLE do { 
			packet = get_null_message();
			succ_rate = rate;
			is_channel_busy = DISABLE; 
		}

		on upload from IDLE to BUSY1 provided (is_channel_busy == DISABLE)  delayable do {
			is_channel_busy = ENABLE; 
			des = get_msg_des(packet);
			printf("                [Channel-d] des: %d\n", des);
		}

		on fail from BUSY1 to IDLE provided(state == DISABLE) delayable do{
			is_channel_busy = DISABLE; 
			des = UNDEFINED;
		}

		on download from BUSY1 to BUSY2 provided(state == ENABLE) delayable

		on done from BUSY2 to IDLE delayable do { 
			is_channel_busy = DISABLE; 
			des = UNDEFINED;
		}
	
	end

	compound type BasicMACM (int appid, int desid)

		component NodeBoot tb(appid)
    		component TaskScheduler ts(appid, 1) // debug: ts disabled
		component EventScheduler es(appid)
		component Timer_New timer1(appid, 300, 0)
		component SampleApplication app1(appid, 0, 1) // noting to post and signal once
		component Sensor sen1(appid)	
		component Environment env(100)  // scuuess rate
		component LED led(appid)

		// bussiness ch/eh/th
		// component EH_Timer eh_timer()
		component CH_Photo_Read ch_photo_read(1000, appid)
		component EH_Photo_ReadDone eh_photo_readdone(appid, desid)
		component CH_DataMsg_Send ch_datamsg_send(1001, appid)
		component EH_DataMsg_SendDone eh_datamsg_senddone(appid)
		component EH_Recvmsg_Receive eh_recvmsg_receive(appid)
		component TH_AVG th_avg(appid)
		
		// radio
		component RadioSender sender(appid)
		component RadioReceiver receiver(appid)

		// System Boot
		connector Conn2 scheduler_init(
			tb.sched_init, 
			ts.init
		)

		connector Conn2 interrupt_init (
			tb.enable_interrupt, 
			es.init
		)
		// boot application
		connector Conn3_Basic app_boot(
			tb.booted, 
			app1.booted,
			timer1.post
		)

		connector Conn_Sen_Ch_Beg conn_sen_ch_beg(
			ch_photo_read.beg,
			led.led1on,
			sen1.read, 
			env.read,
			timer1.sig
		)	
		
		connector Conn_Sig_Photo_Read conn_sig_photo_read(
			sen1.sig, 
			es.sig,
			eh_photo_readdone.init,
			ch_photo_read.sig
		)

		connector Conn2 conn_eh_beg1(
			es.beg,
			eh_photo_readdone.beg
		)

		connector Conn2_M conn_photo_read_call(
			eh_photo_readdone.call_send,
			ch_datamsg_send.beg
		)
		
		connector Conn2_M conn_radio_send(
			ch_datamsg_send.send,
			sender.syn_send
		)
		// provided: if snd succeed // todo sequence problem
		connector Conn3_Radio_Senddone conn_radio_senddone(
			eh_photo_readdone.get_report,
			sender.test,
			ch_datamsg_send.sig
		)

		connector Conn3_Basic conn_photo_read_call2(
			es.fin,
			eh_photo_readdone.call_led2,
			led.led2on
		)
		// may read failed
		connector Conn2 conn_photo_read_fail(
			es.fin,
			eh_photo_readdone.fail
		)
		
		connector Conn3_Datamsg_Senddone conn_datamsg_senddone(	
			eh_datamsg_senddone.init,
			sender.sig,
			es.sig
		) 

		connector Conn2 conn_eh_beg2(
			es.beg,
			eh_datamsg_senddone.beg
		)

		connector Conn4_Basic conn_datamsg_senddone_call(
			es.fin,
			eh_datamsg_senddone.call,
			led.led2off,
			timer1.interval
		)
		// may send failed
		connector Conn3_Basic conn_datamsg_senddone_fail(
			es.fin,
			eh_datamsg_senddone.fail,
			timer1.interval
		)

		// msg receiver
		connector Conn_Data_Receive conn_data_receive(
			es.sig,
			receiver.sig,
			eh_recvmsg_receive.init
		)
		
		connector Conn2 conn_eh_beg3(
			es.beg,
			eh_recvmsg_receive.beg
		)

		connector Conn4_Post_Task conn_recv_eh(
			eh_recvmsg_receive.call,
			led.led0on,
			th_avg.init,
			ts.post
		)
		// avg temp
		connector Conn2 begin_task(
			th_avg.beg, 
			ts.beg
		)

		connector Conn3_Finish fin_task1(
			th_avg.fin, 
			ts.fin,
			es.fin
		)
		// preem enable
		connector Conn7_Preem conn_pre(
			es.pre,
			ch_photo_read.pre,
			eh_photo_readdone.pre,
			ch_datamsg_send.pre,
			eh_datamsg_senddone.pre,
			eh_recvmsg_receive.pre,
			th_avg.pre
		)
		// resume
		connector Conn2 conn_res1(
			es.res,
			ch_photo_read.res
		)

		connector Conn2 conn_res2(
			es.res,
			eh_photo_readdone.res
		)

		connector Conn2 conn_res3(
			es.res,
			ch_datamsg_send.res
		)

		connector Conn2 conn_res4(
			es.res,
			eh_datamsg_senddone.res
		)
		
		connector Conn2 conn_res5(
			es.res,
			eh_recvmsg_receive.res
		) 

		connector Conn2 conn_res6(
			es.res,
			th_avg.res
		)

		export port sender.broadcast as broadcast
		export port receiver.listen as listen
		
	end
	
	compound type Compound()	
		// component SampleNode snode() 
		component BasicMACM node1(1111, 2222)
		component BasicMACM node2(2222, 1111)
		component Channel chan(0)	// faiiled rate

		// node1 to node2
		// 1. try to send
		connector Conn_CSMACA_UP conn_csma_n1_n2_up (
			node1.broadcast,
			chan.upload
		)
		// 2. listen to the channel
		connector Conn2_CSMACA_DOWN conn_csma_n1_n2_down (
			chan.download,
			node2.listen
		)

		// node2 to node1
		// 1. try to send
		connector Conn_CSMACA_UP conn_csma_n2_n1_up (
			node2.broadcast,
			chan.upload
		)
		// 2. listen to the channel
		connector Conn2_CSMACA_DOWN conn_csma_n2_n1_down (
			chan.download,
			node1.listen
		)

	end

end