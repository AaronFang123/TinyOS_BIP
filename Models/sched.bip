@cpp(src="ext-cpp/my_helper.cpp,ext-cpp/scheduler_basic.cpp", include="my_helper.hpp,scheduler_basic.hpp")
package sched
	// Constants definition
	const data int TASK_BUFFER_LIMIT = 255
	const data int NO_TASK = 255
	const data int MAX_TASK_EXECUTION_STEP = 10
	const data int ENABLE = 1
	const data int DISABLE = 0
	const data int UNDEFINED = -1
	// Handler TYPE TaskHandler(TH):0, EventHandler(EH):1, CommandHandler(CH):2
	const data int TYPE_TH = 0
	const data int TYPE_EH = 1
	const data int TYPE_CH = 2		

	// helper function definition
	extern function printf(string)
	extern function printf(string, int)
	extern function printf(string, int, int)
	extern function printf(string, string, int)
	extern function printf(string, int, int, int)
	// to get unique tID
	extern function int get_rand(int)
	extern function init_seed()
	// task queue in ScheulerBasicP.nc
	extern function scheuler_init()
	extern function int push_task(int id)
	extern function int pop_task()
	// event stack 
	extern function push(int)
	extern function int pop()
	extern function bool stack_is_empty()
	extern function bool is_full()
	extern function int get_size()
	extern function create_stack(int)
	extern function destroy_stack()
	// trace helper
	extern function print_s(string)
	
	// Port dinfinition
	port type Port_t()
	port type Port_tv(int v)
	port type Port_e (int eid)
	port type Port_ta (int appid)
	port type Port_ts (int status)
	port type Port_tte (int ext, int t)
	port type Port_tta (int tid, int appid)

	// connectors 
	// basic 2-ports connector: rendz
	connector type Conn2(Port_t p1, Port_t p2)
		define p1 p2	
	end

	// for task to finish
	connector type Conn2_Finish(Port_tta p1, Port_t p2)
		define p1 p2	
		on p1 p2
		provided(p1.tid != 0 && p1.appid != 0)
	end

	// for event beginning
	connector type Conn2_Begin(Port_t p1, Port_t p2)
		define p1 p2
	end

	// test: for 2-TH only , act like a boradcast
	connector type Conn2_Preem(Port_t p1, Port_tta p2)
		define p1' p2
		on p1 down {
			// no task is running ,just do the event
			printf(">>>>>> [Conn2_Preem] no task now, on p1 down\n");
		}
		on p1 p2 down {
			// stack the tids which are preempted
			push(p2.tid);
			printf(">>>>>>  [Conn2_Preem] preempted tasks is stacked, they are %d\n", p2.tid);
		}
	end
	
	connector type Conn2_Resume(Port_t p1, Port_t p2)
		define p1 p2
	end

	// post and signal
	connector type Conn3_PS(Port_ta app ,Port_tta ts, Port_tta th_bound)	
		define app ts th_bound
		on app ts th_bound
		provided (th_bound.tid == 0)
		down {
			th_bound.tid = get_rand(255); 
			th_bound.appid = app.appid;
			ts.tid = th_bound.tid;
			ts.appid = app.appid;
			printf(">>>>>>[Conn3_PS] tid:%d\n", th_bound.tid);		
		}
	end

	// for task beginning	
	connector type Conn3_Begin(Port_ts p1, Port_t p2, Port_t p3)
		define p1 p2 p3
		on p1 p2 p3
		down {
			printf(">>>>>> [Conn3_Begin] Conn3_Begin Task begin\n");
		}
	end

	// atom: Model of Task Schduler
	atom type TaskScheduler()
   		 // variable definition
    		data int task_count = 0
		data int ptv = UNDEFINED
		data int appid = UNDEFINED
		data int tid = UNDEFINED
		data int temp =UNDEFINED
		data int flag_is_running = DISABLE
		
   		 // port instance define
   		export port Port_t beg()
  		export port Port_t fin()
    		export port Port_tta post(tid, appid)	
		port Port_t tick() // spinning	

    		// place define
    		place FREE, BUSY

    		initial to FREE do {
			// initial of task queue
			scheuler_init(); 
			task_count = 0;
        			printf("[TS] initial to FREE  %d\n", task_count);
    		}

   		on beg from FREE to BUSY
		provided (task_count != 0 && flag_is_running == DISABLE)	
 		do {	
			flag_is_running = ENABLE;
			task_count = task_count - 1;
			printf("[TS] on beg from FREE to BUSY tc:%d\n", task_count);
		}

    		on post from FREE to FREE 
		provided (task_count < TASK_BUFFER_LIMIT)
		do{
			temp = push_task(tid);
			// add to queue
			if (tid != UNDEFINED && temp == ENABLE) 
			then 
				printf("------%d\n", tid);
				task_count = task_count + 1;
				printf("[TS] on post from FREE to FREE tc:%d\n", task_count);
			else 
				printf("[USER_DEFINE_ERROR] push failed: %d, errno: %d\n", tid, temp);
			fi
			temp = UNDEFINED;
		}

    		on post from BUSY to BUSY 
		provided (task_count < TASK_BUFFER_LIMIT)
		do{
			temp = push_task(tid);
			// add to queue
			if (tid != UNDEFINED && temp == ENABLE) 
			then 
				task_count = task_count + 1;
				printf("[TS] on post from BUSY to BUSY tc:%d\n", task_count);
			else 
				printf("[USER_DEFINE_ERROR] push failed: %d, errno: %d\n", tid, temp);
			fi
			temp = UNDEFINED;
		}

    		on fin from BUSY to FREE do {
			flag_is_running = DISABLE;
			ptv = pop_task();
			if(ptv == NO_TASK) 
			then 
				printf("[USER_DEFINE_ERROR] pop failed, NO_TASK\n");
			else 
				printf("------ popped task tid %d\n", ptv);
			fi
			printf("[TS] on fin from BUSY to FREE do tc:%d\n", task_count);
			ptv = UNDEFINED;
			tid = UNDEFINED;
		}	

		on tick from FREE to FREE
		provided (task_count == 0)
		do {
			printf("[TS] TS is free now, spinnig\n");
		}
	end


	// the Atom Component of Event Scheduler
	atom type EventScheduler()
		// variable difination
		data int e_count = 0
		data int stack_size = 0
		data int is_es_idle = DISABLE
		data int id = 0
		data int _from = 0

		// exported port defination
		export port Port_t beg()
		export port Port_t pre()
		export port Port_t fin()
		export port Port_tta sig(id, _from)
		export port Port_t res1()  // which e_count == 0
		export port Port_t res2() // which e_count != 0
		export port Port_ts test(is_es_idle)
		
		// internal port difination
	
		// state defination
		place IDLE, ACCEPT, PREEMPT, BUSY1, BUSY2

		// behaviour defination
		initial to IDLE do {
			create_stack(255);
			is_es_idle = ENABLE;
			e_count = 0;
			stack_size = 0;
			printf("[ES] initial to IDLE, ec: %d, ss: %d \n", e_count, stack_size);
		}

		// only when ES is IDLE, TS can start a new task
		on test from IDLE to IDLE do {
			is_es_idle = ENABLE;
			printf("[ES] ES is still IDLE now, spinning\n");
		}

		on sig from IDLE to ACCEPT do {
			is_es_idle = DISABLE;
			printf("[ES] on sig from IDLE to ACCEPT, ec: %d, ss: %d\n", e_count, stack_size);
		} 

		on pre from ACCEPT to PREEMPT do {
			stack_size = get_size();
			printf("[ES] on pre from ACCEPT to PREEMPT, ec: %d, ss: %d\n", e_count, stack_size);
		}

		on beg from PREEMPT to BUSY1 do {
			e_count = e_count + 1;
			printf("[ES] on beg from PREEMPT to BUSY1, ec: %d, ss: %d\n", e_count, stack_size);
		}
		
		on fin from BUSY1 to IDLE 
		provided(stack_size == 0)
		do {
			e_count = e_count - 1;
			printf("[ES] on fin from BUSY1 to IDLE, ec: %d, ss: %d\n", e_count, stack_size);
		}
		
		on fin from BUSY1 to BUSY2
		provided(stack_size != 0)
		do {
			pop(); 	// pop from stack
			stack_size = get_size();
			e_count = e_count - 1;
			printf("[ES] on fin from BUSY1 to BUSY2, ec: %d, ss: %d\n", e_count, stack_size);
		}

		on res2 from BUSY2 to BUSY1
		provided(e_count > 0)
		do {
			printf("[ES] on res from BUSY2 to BUSY1, ec: %d, ss: %d\n", e_count, stack_size);
		}

		on res1 from BUSY2 to IDLE
		provided(e_count == 0)
		do {
			printf("[ES] on res from BUSY2 to IDLE, ec: %d, ss: %d\n", e_count, stack_size);
		}

		// priority definition, it means when 'sig' interaction comes, 'test' interaction must step back 
		// priority idle_state_change test < sig
		
	end	

	// atom type of Task and Event Handler
	atom type Handler(int tp)
		
		data int exe_step = 0
		data int tid = 0
		data int appid = 0
		data string TAG = ""		

		// port definition 
		export port Port_tta init(tid, appid)
		export port Port_t beg()
		export port Port_tta fin(tid, appid)
		export port Port_tta pre(tid, appid)
		export port Port_t res()
		port Port_t exe()

		// state definition
		place IDLE, BOUND, EXE, SUSP

		// behavior definition
		initial to IDLE do {
			if(tp == 0) then 
				TAG = "[TH]"; 
			else 
				if(tp == 1) then
					TAG = "[EH]"; 
				else
					TAG = "[CH]";
				fi
			fi
			print_s(TAG); printf("initial to IDLE\n");
		}

		on init from IDLE to BOUND do {
			print_s(TAG); printf("on init from IDLE to BOUND do , appid: %d, id: %d\n", appid, tid);
		}
		
		on beg from BOUND to EXE do{
			print_s(TAG); printf("on begin from IDLE to EXE, id:%d\n", tid);
		} 

		// this is internal
		on exe from EXE to EXE 
		provided(exe_step < MAX_TASK_EXECUTION_STEP)
		do {
			exe_step = exe_step + 1;
			print_s(TAG); printf("executing, id:%d, step: %d\n", tid, exe_step);
		}

		on fin from EXE to IDLE do {
			print_s(TAG); printf(" on fin from EXE to IDLE, id:%d\n", tid);
		}

		on pre from EXE to SUSP do {
			print_s(TAG); printf(" on pre from EXE to SUSP, th is premeeted, going to SUSPEND, id:%d\n", tid);
		}

		on res from SUSP to EXE do {
			print_s(TAG); printf(" on res from SUSP to EXE, id:%d\n", tid);
		}
			
	end
	
	atom type Timer( int timer_id) 
		data int expire_in = UNDEFINED
		data int count_down = UNDEFINED
		data int t = UNDEFINED
		// port definition
		export port Port_tte post(expire_in, t)
		export port Port_t sig()
		port Port_t tick()
		
		// state definition
		place EXE, DONE
		
		// interaction definition
		initial to EXE do {
			count_down = 0;
			printf("[Timer] timer %d init\n", timer_id);
		}
	
		on post from EXE to EXE 
		provided (count_down == 0)
		do {
			count_down = expire_in;
			printf("[Timer] on post from EXE to EXE, new event set:%d, expire in:%d, timer ID: %d\n", t, expire_in, timer_id);
		}

		on tick from EXE to EXE
		provided (count_down >= 1)
		do {
			// todo: real time related?
			count_down = count_down - 1;
		}
		
		on sig from EXE to DONE
		provided (count_down == 0)
		do {
			printf("[Timer] on sig from EXE to DONE,  event: %d, expire in %d\n, timer ID: %d", t, expire_in, timer_id);
		}
	end

	atom type Sensor(int _sid)		
		// data definition
		data int sid = UNDEFINED
		data int sig_limit = UNDEFINED

		// port definition
		port Port_t beg()
		export port Port_ta sig(sid)

		// state definition
		place IDLE, EXE

		initial to IDLE do {
			sid = _sid;
			sig_limit = 1;
			printf("[Sensor] sensor sid: %d\n", sid);
		}
		
		on beg from IDLE to EXE do{
			printf("[Sensor] on beg from IDLE to EXE, sid: %d\n", sid);
		} 

		on sig from EXE to EXE 
		provided(sig_limit > 0)
		do {	
			sig_limit = sig_limit - 1;	
			printf("[Sensor] on sig from EXE to EXE, sid: %d\n", sid);
		}
		
	end

	// user defined software component
	atom type UserApplication(int _appid, int task_count)
		
		data int posted_task_count = 0
		data int appid
		
		// port definition
		export port Port_ta post(appid)
		port Port_t start()
		port Port_t ret()
		port Port_t fin()
		
		place INIT, POSTING, RUNNING, FIN

		initial to INIT do {
			init_seed();
			appid = _appid;
			printf("[UA] APP %d init\n", appid);
		} 
		
		on start from INIT to RUNNING do {
			printf("[UA] APP %d begins running\n", appid);
		}

		on post from RUNNING to POSTING 
		provided(posted_task_count < task_count)
		do {
			posted_task_count  = posted_task_count + 1;
			printf("[UA] APP %d posting a task\n", appid);	
		}
		
		on ret from POSTING to RUNNING do {
			printf("[UA] APP %d continue to run\n", appid); 
		}

		on fin from RUNNING to FIN 
		provided(posted_task_count == task_count)
		do {
			printf("[UA] APP %d is done\n", appid);
		}	
		
	end

	// for Sensor, it will provide a random value as the return value of senors
	atom type Environment() 
		// data definition
		data int value
		// port definition
		export port Port_tv read(value)
		// state definition
		place DO
		// interaction definition
		initial to DO do {
			value = get_rand(100000);
		}
			
		on read from DO to DO do {
			value = get_rand(100000);
		}
	
	end

	// main
	compound  type  Compound() 
		// components
    		component TaskScheduler ts()
		component EventScheduler es()

		// component Timer timer1(111)
		component Sensor sen1(456)		
		component UserApplication app1(1, 2)

		component Handler th_app1_1(TYPE_TH), th_app1_2(TYPE_TH)
		component Handler eh_sen1_data_ready(TYPE_EH)
		component Handler ch_sen1_get_data(TYPE_CH) // callback

		// connectors
		// post task
		connector Conn3_PS post_task1(app1.post, ts.post, th_app1_1.init)
		connector Conn3_PS post_task2(app1.post, ts.post, th_app1_2.init)
		// the link of tasksched and its handler: begin
		connector Conn3_Begin begin_task1(es.test, th_app1_1.beg, ts.beg)					
		connector Conn3_Begin begin_task2(es.test, th_app1_2.beg, ts.beg)
		// the link of tasksched and its handler: finish
		connector Conn2_Finish fin_task1(th_app1_1.fin, ts.fin)
		connector Conn2_Finish fin_task2(th_app1_2.fin, ts.fin)	
		
		// the following is for test: meet the basic demanding
		connector Conn2_Preem test_pree1(es.pre, th_app1_1.pre)
		connector Conn2_Preem test_pree2(es.pre, th_app1_2.pre)

		connector Conn2_Resume test_res1(es.res1, th_app1_1.res)
		connector Conn2_Resume test_res2(es.res1, th_app1_2.res)

		// Sensor sig, it will sig anytime
		connector Conn3_PS sig_event1(sen1.sig, es.sig, eh_sen1_data_ready.init)
		connector Conn2_Begin begin_event1(eh_sen1_data_ready.beg, es.beg)
		connector Conn2_Finish fin_event1(eh_sen1_data_ready.fin, es.fin)
	end
end