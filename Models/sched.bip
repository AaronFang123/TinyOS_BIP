@cpp(include="stdio.h")
package sched
	// Constants definition
	const data int TASK_BUFFER_LIMIT = 255

	// helper function definition
	extern function printf(string)
	extern function printf(string, int)
	
	// Port dinfinition
	port type Port_t()


	// connectors
	// boradcast

	connector type Conn2(Port_t p1, Port_t p2)
		define p1 p2	
	end
	
	connector type TBegConn3(Port_t sched ,Port_t p1, Port_t p2)
		define sched' p1 p2
	end

	// rendezvous
	connector type TFinConn3(Port_t sched ,Port_t p1, Port_t p2)
		define sched p1 p2
	end


	// atom: Model of Task Schduler
	atom type TaskScheduler()
   		 // variable definition
    		data int task_count = 0
		
   		 // port instance define
   		export port Port_t beg()
  		export port Port_t fin()
    		export port Port_t post()

    		// place define
    		place FREE, BUSY

    		initial to FREE do {
			task_count = 0;
        			printf("[TS] initial to FREE  %d\n");
    		}

   		on beg from FREE to BUSY
		provided (task_count != 0)	
 		do {
			task_count = task_count - 1;
			printf("[TS] on beg from FREE to BUSY tc:%d\n", task_count);
		}

    		on post from FREE to FREE 
		provided (task_count < TASK_BUFFER_LIMIT)
		do{
			task_count = task_count + 1;
			printf("[TS] on post from FREE to FREE tc:%d\n", task_count);
		}

    		on post from BUSY to BUSY 
		provided (task_count < TASK_BUFFER_LIMIT)
		do{
			task_count = task_count + 1;
			printf("[TS] on post from BUSY to BUSY tc:%d\n", task_count);
		}

    		on fin from BUSY to FREE do {
			printf("[TS] on fin from BUSY to FREE do tc:%d\n", task_count);
		}	
	end


	// the Atom Component of Event Scheduler
	atom type EventScheduler()
		// variable difination
		data int e_count = 0
		data int stack_size = 0

		// exported port defination
		export port Port_t beg()
		export port Port_t pre()
		export port Port_t res()
		// internal port difination
		export port Port_t fin()
		export port Port_t sig()

		// state defination
		place IDLE, ACCEPT, PREEMPT, BUSY1, BUSY2

		// behaviour defination
		initial to IDLE do {
			e_count = 0;
			stack_size = 0;
			printf("[ES] initial to IDLE\n");
			printf("ec: %d\n", e_count);
			printf("ss: %d\n", stack_size);

		}

		on sig from IDLE to ACCEPT do {
			printf("[ES] on sig from IDLE to ACCEPT\n");
			printf("ec: %d\n", e_count);
			printf("ss: %d\n", stack_size);
		} 

		on pre from ACCEPT to PREEMPT do {
			stack_size = stack_size + 1;
			printf("[ES] on pre from ACCEPT to PREEMPT\n");
			printf("ec: %d\n", e_count);
			printf("ss: %d\n", stack_size);
		}

		on beg from PREEMPT to BUSY1 do {
			e_count = e_count + 1;
			printf("[ES] on beg from PREEMPT to BUSY1\n");
			printf("ec: %d\n", e_count);
			printf("ss: %d\n", stack_size);
		}
		
		on fin from BUSY1 to IDLE 
		provided(stack_size == 0)
		do {
			e_count = e_count - 1;
			printf("[ES] on fin from BUSY1 to IDLE\n");
			printf("ec: %d\n", e_count);
			printf("ss: %d\n", stack_size);
		}
		
		on fin from BUSY1 to BUSY2
		provided(stack_size != 0)
		do {
			stack_size = stack_size - 1;
			e_count = e_count - 1;
			printf("[ES] on fin from BUSY1 to BUSY2\n");
			printf("ec: %d\n", e_count);
			printf("ss: %d\n", stack_size);
		}

		on res from BUSY2 to BUSY1
		provided(e_count > 0)
		do {
			printf("[ES] on res from BUSY2 to BUSY1\n");
			printf("ec: %d\n", e_count);
			printf("ss: %d\n", stack_size);
		}

		on res from BUSY2 to IDLE
		provided(e_count ==0)
		do {
			printf("[ES] on res from BUSY2 to IDLE\n");
			printf("ec: %d\n", e_count);
			printf("ss: %d\n", stack_size);
		}

	end	

	// atom type of Task Handler
	atom type TaskHandler(int tid)
		
		// port definition 
		export port Port_t beg()
		export port Port_t fin()
		export port Port_t pre()
		export port Port_t res()
		port Port_t exe()

		// state definition
		place IDLE, EXE, SUSP

		// behavior definition
		initial to IDLE do {
			printf("[TH] initial to IDLE, tid:%d\n", tid);
		}
		
		on beg from IDLE to EXE do{
			printf("[TH] on begin from IDLE to EXE, tid:%d\n", tid);
		} 

		// this is internal
		on exe from EXE to EXE do {
			printf("[TH] Task is executing, tid:%d\n", tid);
		}

		on fin from EXE to IDLE do {
			printf("[TH] on fin from EXE to IDLE, tid:%d\n", tid);
		}

		on pre from EXE to SUSP do {
			printf("[TH] on pre from EXE to SUSP, tid:%d\n", tid);
		}

		on res from SUSP to EXE do {
			printf("on res from SUSP to EXE, tid:%d\n", tid);
		}
			
	end

	// atom type of Event Handler
	// atom type EventHandler()

		// port definition
		//export port Port_t pre()
		//export port Port_t res()
		//export port Port_t fin()
		//export port Port_t beg()
	// end

	// atom type of Command Handler
	// atom type CommandHandler()
		
		// port definition
		//export port Port_t pre()
		//export port Port_t res()
	//end

	// user defined software component
	atom type UserApplication(int appid)
		
		// port definition
		export port Port_t post()
		port Port_t start()
		port Port_t res()
		port Port_t fin()
		
		place INIT, POSTING, RUNNING, FIN

		initial to INIT do {
			printf("[UA] APP %d init\n", appid);
		} 
		
		on start from INIT to RUNNING do {
			printf("[UA] APP %d begins running\n", appid);
		}

		on post from RUNNING to POSTING do {
			printf("[UA] APP %d posting a task\n", appid);	
		}
		
		on res from POSTING to RUNNING do {
			printf("[UA] APP %d continue to run\n", appid); 
		}

		on fin from RUNNING to FIN do {
			printf("[UA] APP %d is done\n", appid);
		}	
		
	end

	// main
	compound  type  Compound() 
		// components
    		component TaskScheduler ts()
		// component TaskHandler t1(1), t2(2)
		component UserApplication app1(1), app2(2)
		
		connector Conn2 post_task1(ts.post, app1.post)
		connector Conn2 post_task2(ts.post, app2.post)
		// connectors
	end

end